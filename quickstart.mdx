---
title: "Quickstart"
description: "Get up and running with Chainrails in minutes."
---

## Overview

Every Chainrails transaction follows three simple steps from setup to completion:

#### Request a Quote

Define the parameters for the transaction (the intent) — amount, source chain, source token, destination chain, recipient, and refund address.
This tells Chainrails what the user wants to send and where it’s going.

#### Generate an Intent Address

Once the quote is confirmed, Chainrails creates a unique intent address for that transaction.
Think of this as a one-time deposit address that tracks and processes the transfer logic automatically.

#### Fund the Intent

The user then funds this intent address directly from their wallet.
Once funded, Chainrails takes care of the rest — executing the cross-chain transfer, routing liquidity, and confirming settlement.

The SDK abstracts most of these steps, so you can integrate this entire flow in just a few lines of code.
In this Quickstart, we’ll walk you through how to get up and running in minutes.

## Get started in three steps

<Steps>
<Step title="Installation">
Begin by installing the Chainrails React SDK.

```bash
npm install @chainrails/react @chainrails/sdk
```

</Step>

<Step title="Set up a Session Endpoint">
Create a backend endpoint that generates secure session tokens. This protects your API key and prevents abuse.

<Tabs>
  <Tab title="Next.js API Route">
```javascript
import { Chainrails, crapi } from "@chainrails/sdk";

Chainrails.config({
  api_key: process.env.CHAINRAILS_API_KEY,
  env: "production",
});

export default async function handler(req, res) {
  if (req.method !== "POST") {
    return res.status(405).json({ error: "Method not allowed" });
  }

  const { destinationChain, token, amount, recipient } = req.body;

  // Optional: Add your own validation/auth here
  try {
    const session = await crapi.auth.getSessionToken({
      amount,
      recipient,
      destinationChain,
      token,
    });

    res.status(200).json(session);
  } catch (error) {
    res.status(500).json({ error: "Failed to create session" });
  }
}
```
  </Tab>

  <Tab title="Express.js">
```javascript
import express from "express";
import { Chainrails, crapi } from "@chainrails/sdk";

const app = express();
app.use(express.json());

Chainrails.config({
  api_key: process.env.CHAINRAILS_API_KEY,
  env: "production",
});

app.post("/api/chainrails/session", async (req, res) => {
  const { destinationChain, token, amount, recipient } = req.body;

  // Optional: Add your own validation/auth here
  try {
    const session = await crapi.auth.getSessionToken({
      amount,
      recipient,
      destinationChain,
      token,
    });

    res.json(session);
  } catch (error) {
    res.status(500).json({ error: "Failed to create session" });
  }
});
```
  </Tab>

  <Tab title="Vercel Serverless">
```javascript
import { Chainrails, crapi } from "@chainrails/sdk";

Chainrails.config({
  api_key: process.env.CHAINRAILS_API_KEY,
  env: "production",
});

export default async function handler(req, res) {
  if (req.method !== "POST") {
    return res.status(405).json({ error: "Method not allowed" });
  }

  const { destinationChain, token, amount, recipient } = req.body;

  try {
    const session = await crapi.auth.getSessionToken({
      amount,
      recipient,
      destinationChain,
      token,
    });

    res.status(200).json(session);
  } catch (error) {
    res.status(500).json({ error: "Failed to create session" });
  }
}
```
  </Tab>
</Tabs>

<Warning>
  **Keep your API key secure:** Never expose `CHAINRAILS_API_KEY` in client-side code. 
  Always create session tokens server-side.
</Warning>
</Step>

<Step title="Initialize the Payment Modal">
Import and initialize the Chainrails payment modal in your application.

```javascript
import { chains, tokens, PaymentModal, usePaymentSession } from "@chainrails/react"

function App() {
  const cr = usePaymentSession({
    session_url: "https://your-server.com/create-session",
    destinationChain: chains.BASE,
    token: tokens.USDC,
    recipient: "0x4F41BCf288E718A36c1e6919c2Dfc2E07d51c675",
    amount: 1, // Optional: Set to 0, to let users input their own amount
    onCancel: () => {
      console.log("Payment Cancelled")
    },
    onSuccess: () => {
      console.log("Payment Successful")
    },
  })

  return (
    <div>
      <button onClick={cr.open}>Pay with Crypto</button>
      <PaymentModal {...cr} />
    </div>
  )
}
```

**Parameters:**

- `session_url` (required): Your backend endpoint that creates session tokens
- `amount` (optional): Set to 0, to let users input their own amount
- `recipient` (optional): Your wallet address - only needed if not set in backend
- `destinationChain` (optional): The blockchain network - only needed if not set in backend
- `token` (optional): The token you want to receive - only needed if not set in backend
- `onSuccess` (optional): Callback when payment completes successfully
- `onCancel` (optional): Callback when user cancels the payment

<Note>
  **Backend vs Frontend Config:** Values set in your backend take precedence. 
  Only pass `recipient`, `destinationChain`, `token` and `amount` from the frontend if they vary per transaction.
</Note>

</Step>
</Steps>

## What happens next?

When users click the payment button:

1. The SDK fetches a secure session token from your backend
2. Users see the payment modal with their wallet connection options
3. They can pay from any supported chain/token (Chainrails handles bridging)
4. Your `onSuccess` callback fires when the transaction completes
5. Funds arrive in your `recipient` address on your chosen chain

<Card title="View Demo" icon="stars" href="https://chainrails.io/demo">
  See a live example of Chainrails in action
</Card>
